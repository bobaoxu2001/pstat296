---
title: "296Data_SBBI"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# SBBI Raw Data for Capital Markets (2022_10_21)
```{r}
#install.packages("qpcR")
#install.packages("rgl")
```

```{r,echo=FALSE, result = 'hide',fig.show='hide',message=FALSE}
setwd("/Users/xuao/Documents/PSTAT296A/pstat296")
library(tsdl) 
library(forecast) 
library(tidyverse) 
library(astsa)
library(MASS) 
library(ggplot2) 
library(ggfortify) 
library(forecast) 
library(GeneCycle) 
library(qpcR) 
require(TSA) 
#source("plot.roots.R")
```

```{r}
rm(list = ls())
```

# Import SBBI Raw Data for Capital Markets (2022_10_21)
```{r}
#TR26_21 <- read_excel("/Users/xuao/Documents/PSTAT296A/pstat296/SBBI Data for Capital Markets (2022_10_21).xlsx", sheet =  "Processed")
colnames(TR26_21) <- c("Observed Month", "Large Cap TR", "LT Govt TR 20 YR","IT Govt TR 5 YR","LT Corp TR 20 YR","T-Bill TR 30 DAY","US CPI/ INFLATION","LT Govt Yield 20 YEAR","IT Govt Yield 5 YEAR")
TR26_21 <- TR26_21 %>%
  filter(!row_number() %in% c(1:5)) %>%
  janitor::clean_names()
TR26_21 <- as.data.frame(sapply(TR26_21, as.numeric))
TR26_21 <- TR26_21 %>%
  mutate(observed_month = as.Date(observed_month,origin = "1899-12-30")) 
#TR26_21
```

```{r}
Govt_20_Yield <- TR26_21[,c(1,8)]
Govt_20_Yield$yield_percentage <- round(Govt_20_Yield$lt_govt_yield_20_year*100, digits = 3)
#Govt_20_Yield$yield_percentage
```

```{r}
summary(Govt_20_Yield$yield_percentage)
```
```{r}
plot(Govt_20_Yield$yield_percentage,type="l")
```
```{r}
train <- Govt_20_Yield$yield_percentage[700:1140]
test <- Govt_20_Yield$yield_percentage[1141:1152]
#train
#test
```


```{r}
tsdata <- ts(train, frequency = 12) 
ts.plot(tsdata)
```

```{r}
hist(tsdata, main="Histogram",
xlab="date")
```
```{r}
# Box-Cox transformation:
t <- 1:length(tsdata)
bcTransform <- boxcox(tsdata ~ t, plotit=TRUE)
```
```{r}
lambda <- bcTransform$x[which.max(bcTransform$y)]
lambda
tsdata.bc = (1/lambda)*(tsdata^lambda-1)
# Plot and compare the two:
par(mfrow=c(1, 2))
ts.plot(tsdata, main = "Original data",ylab = expression(X[t]))
ts.plot(tsdata.bc, main = "Box-Cox tranformed data", ylab = expression(Y[t]))
```
```{r}
# Compare tsdata and tsdata.bc
par(mfrow=c(2,3))
plot.ts(tsdata,xlab = "", main = "")
hist(tsdata, col = "light blue", xlab = "", main = "") 
qqnorm(tsdata, main = "", xlab = "")
qqline(tsdata, col = "red")
plot.ts(tsdata.bc,xlab = "", main = "")
hist(tsdata.bc, col = "light blue", xlab = "", main = "")
qqnorm(tsdata.bc, main = "", xlab = "")
qqline(tsdata.bc, col = "red")
```
So transformation makes it more normal
```{r}
hist(tsdata.bc)
```
decompose
```{r}
decomp <- decompose(tsdata)
plot(decomp)
```

```{r}
# Remove seasonality and trend
tsdata_12 <- diff(tsdata, lag = 12)
tsdata_12_1 <- diff(tsdata_12, lag = 1)
tsdata_12_1_1 <- diff(tsdata_12_1, lag = 1)
```
```{r}
# To check number differencing par(mfrow=c(1,2))
plot.ts(tsdata_12, main = "")
abline(h=mean(tsdata_12), col = "blue")
plot.ts(tsdata_12_1, main = "")
abline(h=mean(tsdata_12_1), col = "blue")
```

```{r}
# Plot it:
#par(mfrow=c(1, 1))
#ts.plot(y.12, main="De-seasonlized Time Series",ylab=expression(nabla[12]~Y[t]))
#abline(h=mean(y.12), lty=2)
```

```{r}
# Compare the ACF and PACF of tsdata, tsdata_12, and tsdata_12_1 par(mfrow=c(2,3))
par(mfrow=c(2,3))
acf(tsdata, lag.max = 60, main = expression(U[t]))
acf(tsdata_12, lag.max = 60, main = expression(nabla[12]~~U[t]))
acf(tsdata_12_1, lag.max = 60, main = expression(nabla[1]~nabla[12]~~U[t])) 
pacf(tsdata, lag.max = 60, main = "")
pacf(tsdata_12, lag.max = 60, main = "")
pacf(tsdata_12_1, lag.max = 60, main = "")
```
For Sarima Model,

Choose d = D = 1;

We find that the ACF plot of ∇1∇12tsdata shows spikes at lag 1, 3, 13.

We find that the PACF plot of ∇1∇12tsdata shows spikes at lag 2, 12.

Then we can assume q = 0 or 1 or 3 , p = 0 or 1 or 2. Q = 1, P = 0
```{r}
# Candidate models:
df <- expand.grid(p=0:1, q=0:1, P=0:2, Q=0:1)
df <- cbind(df, AICc=NA)
# Compute AICc:
for (i in 1:nrow(df)) {
  sarima.obj <- NULL
  try(arima.obj <- arima(tsdata.bc, order=c(df$p[i], 0, df$q[i]),seasonal=list(order=c(df$P[i], 1, df$Q[i]),period=12),method="ML"))
  if (!is.null(arima.obj)) { df$AICc[i] <- AICc(arima.obj) }
# print(df[i, ])
}
df[which.min(df$AICc), ]
```
```{r}
# Calculate the AICc of possible models
a <- AICc(arima(tsdata.bc, order = c(0,1,0),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
b<- AICc(arima(tsdata.bc, order = c(0,1,1),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
c<- AICc(arima(tsdata.bc, order = c(0,1,3),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
d<- AICc(arima(tsdata.bc, order = c(1,1,0),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
e<- AICc(arima(tsdata.bc, order = c(1,1,1),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
f<- AICc(arima(tsdata.bc, order = c(1,1,3),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
g<- AICc(arima(tsdata.bc, order = c(2,1,0),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
h<- AICc(arima(tsdata.bc, order = c(2,1,1),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
i<- AICc(arima(tsdata.bc, order = c(2,1,3),
seasonal = list(order = c(0,1,1), period = 12), method = "ML"))
AICc_value <- rbind(a,b,c,d,e,f,g,h,i) 
rownames(AICc_value)<-c("$SARIMA(0,1,0)(0,1,1)_{12}$", "$SARIMA(0,1,1)(0,1,1)_{12}$",
"$SARIMA(0,1,3)(0,1,1)_{12}$", "$SARIMA(1,1,0)(0,1,1)_{12}$", "$SARIMA(1,1,1)(0,1,1)_{12}$","$SARIMA(1,1,3)(0,1,1)_{12}$", "$SARIMA(2,1,0)(0,1,1)_{12}$","$SARIMA(2,1,1)(0,1,1)_{12}$", "$SARIMA(2,1,3)(0,1,1)_{12}$")
colnames(AICc_value) <-c("AICc") 
knitr::kable(AICc_value)
```

Since SARIMA(2,1,0)(0,1,1)12 has the least value of AICC, so we choose SARIMA(2,1,0)(0,1,1)12.
```{r}
# Estimate coefficients
arima(tsdata, order = c(0,1,1),
seasonal = list(order = c(0,1,1), period = 12), method = "ML")
# Check for invertible
polyroot(c(1, -0.3642))
# Plot the residuals
fit1 <- arima(tsdata, order = c(0,1,1),
seasonal = list(order = c(0,1,1), period = 12), method = "ML") 
res1 <- residuals(fit1)
plot.ts(res1, xlab = "")
abline(h=mean(res1),col = "blue")
# Plot the histogram, Q-Q normal plot of the residual par(mfrow=c(1,2))
hist(res1, density = 20, breaks = 20,col = "blue", xlab = "", prob = TRUE, main = "")
m1 <- mean(res1)
std1 <- sqrt(var(res1)) 
curve(dnorm(x,m1,std1),add = TRUE) 
qqnorm(res1,main = "", xlab = "") 
qqline(res1, col = "blue")
# Plot the ACF and PACF of the residual
par(mfrow=c(1,2)) 
acf(res1,lag.max=60, main = "") 
pacf(res1,lag.max=60, main = "")
```


```{r}
# Final model:
ind <- which.min(df$AICc)
fit <- arima(tsdata.bc, order=c(df$p[ind], 1, df$q[ind]),
seasonal=list(order=c(df$P[ind], 1, df$Q[ind]), period=12),
method="ML")
```

```{r}
# Residual plots:
res <- residuals(fit)
mean(res); var(res)
```

```{r}
# layout(matrix(c(1, 1, 2, 3), 2, 2, byrow=T))
par(mfrow=c(1, 1))
ts.plot(res, main="Fitted Residuals")
t <- 1:length(res)
fit.res = lm(res~ t)
abline(fit.res)
abline(h = mean(res), col = "red")
```
```{r}
# ACF and PACF:
par(mfrow=c(1, 2))
acf(res, main="Autocorrelation")
pacf(res, main="Partial Autocorrelation")
```
```{r}
# Test for independence of residuals
Box.test(res, lag = 9, type = c("Box-Pierce"), fitdf = 1)
```

```{r}
Box.test(res, lag = 9, type = c("Ljung-Box"), fitdf = 1)
```

```{r}
Box.test(res^2, lag = 9, type = c("Ljung-Box"), fitdf = 0)
```
```{r}
# Test for normality of residuals
shapiro.test(res)
```

```{r}
# Histogram and QQ-plot:
par(mfrow=c(1,2))
hist(res,main = "Histogram")
qqnorm(res)
qqline(res,col ="blue")
```
#
```{r}
# Perform test on Model 1's residual
shapiro.test(res1)
Box.test(res1,lag = 20, type = c("Box-Pierce"),fitdf = 2) 
Box.test(res1,lag = 20, type = c("Ljung-Box"),fitdf = 2) 
Box.test(res1^2,lag = 20, type = c("Ljung-Box"),fitdf = 0) 
ar(res1,aic=TRUE,order.max=NULL, mehod = c("yule-walker"))
```
```{r}
# Predict 30 future observations and plot
par(mfrow=c(1, 1))
mypred <- sarima.for(train, n.ahead = 30, p=2, d=1, q=0, P=, D=1, Q=1, S=12)
points(1141:1152, test, col="yellow")
```

```{r}
# Predict 10 future observations and plot
par(mfrow=c(1, 1))
mypred <- predict(fit, n.ahead=60)
ts.plot(c(tsdata.bc), xlim=c(1, length(tsdata) + 60), ylim=c(min(tsdata)*0.8, max(tsdata)*1.2))
points((length(tsdata) + 1):(length(tsdata) + 60), col="red", (lambda*mypred$pred + 1)^(1/lambda))
lines((length(tsdata) + 1):(length(tsdata) + 60), (lambda*mypred$pred + 1.96*mypred$se + 1)^(1/lambda), lty=2)
lines((length(tsdata) + 1):(length(tsdata) + 60),(lambda*mypred$pred - 1.96*mypred$se + 1)^(1/lambda), lty=2)
```

```{r}
# Predict 10 future observations and plot
par(mfrow=c(1, 1))
mypred <- predict(fit, n.ahead=120)
ts.plot(c(tsdata), xlim=c(200, length(tsdata) + 120), ylim=c(min(tsdata)*0.8, max(tsdata)*1.2))
points((length(tsdata) + 1):(length(tsdata) + 120), col="red", (lambda*mypred$pred + 1)^(1/lambda))
lines((length(tsdata) + 1):(length(tsdata) + 120), (lambda*mypred$pred + 1.96*mypred$se + 1)^(1/lambda), lty=2)
lines((length(tsdata) + 1):(length(tsdata) + 120),(lambda*mypred$pred - 1.96*mypred$se + 1)^(1/lambda), lty=2)
```


